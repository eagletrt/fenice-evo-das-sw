/******************************************************************************
Finite State Machine
Project: VFSM
Description: vehicle_fsm

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.3
Generation date: 2022-10-07 17:11:13 +0200
Generated from: fsm.dot
The finite state machine has:
  12 states
  0 transition functions
Functions and types have been generated with prefix "VFSM_"
******************************************************************************/

#ifndef FSM_H
#define FSM_H
#include <stdlib.h>

// State data object
typedef void VFSM_state_data_t;

// List of states
typedef enum {
  VFSM_STATE_INIT = 0,  
  VFSM_STATE_ENABLE_INV_UPDATES,  
  VFSM_STATE_CHECK_INV_SETTINGS,  
  VFSM_STATE_IDLE,  
  VFSM_STATE_FATAL_ERROR,  
  VFSM_STATE_START_TS_PRECHARGE,  
  VFSM_STATE_WAIT_TS_PRECHARGE,  
  VFSM_STATE_START_TS_DISCHARGE,  
  VFSM_STATE_WAIT_DRIVER,  
  VFSM_STATE_ENABLE_INV_DRIVE,  
  VFSM_STATE_DRIVE,  
  VFSM_STATE_DISABLE_INV_DRIVE,  
  VFSM_STATE_WAIT_TS_DISCHARGE,  
  VFSM_NUM_STATES,
  VFSM_NO_CHANGE
} VFSM_state_t;

// State human-readable names
extern const char *VFSM_state_names[];

// State function prototype
typedef VFSM_state_t state_func_t(VFSM_state_data_t *data);


/**
 * @brief     The controller is being initialized
 */
VFSM_state_t VFSM_do_init(VFSM_state_data_t *data);

// Function to be executed in state enable_inv_updates
// valid return states: VFSM_STATE_CHECK_INV_SETTINGS
VFSM_state_t VFSM_do_enable_inv_updates(VFSM_state_data_t *data);

// Function to be executed in state check_inv_settings
// valid return states: VFSM_STATE_IDLE, VFSM_STATE_FATAL_ERROR
VFSM_state_t VFSM_do_check_inv_settings(VFSM_state_data_t *data);


/**
 * @brief     The DAS in waiting for a TS-ON request from the steering wheel
 */
VFSM_state_t VFSM_do_idle(VFSM_state_data_t *data);

// Function to be executed in state fatal_error
// valid return states: VFSM_NO_CHANGE, VFSM_STATE_FATAL_ERROR
VFSM_state_t VFSM_do_fatal_error(VFSM_state_data_t *data);


/**
 * @brief     Ask the TS to enter the precharge state and wait until it does
 */
VFSM_state_t VFSM_do_start_ts_precharge(VFSM_state_data_t *data);

/**
 * @brief     Wait until the TS finished the precharge step
 */
VFSM_state_t VFSM_do_wait_ts_precharge(VFSM_state_data_t *data);

/**
 * @brief     The TS is ON, wait until the driver presses the brake and asks to enter RTD
 */
VFSM_state_t VFSM_do_wait_driver(VFSM_state_data_t *data);

/**
 * @brief     Ask the TS to power off and wait until it does
 */
VFSM_state_t VFSM_do_start_ts_discharge(VFSM_state_data_t *data);


/**
 * @brief     Command the inverters to enable the power output and wait until it's on
 */
VFSM_state_t VFSM_do_enable_inv_drive(VFSM_state_data_t *data);

/**
 * @brief     Read pedal values and set the inverters' torque accordingly
 */
VFSM_state_t VFSM_do_drive(VFSM_state_data_t *data);

/**
 * @brief     Command the inverters to disable the power output and wait until it's off
 */
VFSM_state_t VFSM_do_disable_inv_drive(VFSM_state_data_t *data);

/**
 * @brief     Open the SD circuit and wait for the TS voltage to drop below 60v
 */
VFSM_state_t VFSM_do_wait_ts_discharge(VFSM_state_data_t *data);


// List of state functions
extern state_func_t *const VFSM_state_table[VFSM_NUM_STATES];


// State manager
VFSM_state_t VFSM_run_state(VFSM_state_t cur_state, VFSM_state_data_t *data);

#endif
