/******************************************************************************
Finite State Machine
Project: VFSM
Description: vehicle_fsm

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.3
Generation date: 2022-10-07 17:11:13 +0200
Generated from: fsm.dot
The finite state machine has:
  13 states
  0 transition functions
Functions and types have been generated with prefix "VFSM_"
******************************************************************************/

#include "fsm.h"

#include "buzzer.h"
#include "logger.h"
#include "can_messages.h"
#include "pedals.h"
#include "tractive_system.h"


/* State human-readable names */
const char *VFSM_state_names[] = {"init", "enable_inv_updates", "check_inv_settings", "idle", "fatal_error", "start_ts_precharge", "wait_ts_precharge", "start_ts_discharge", "wait_driver", "enable_inv_drive", "drive", "disable_inv_drive", "wait_ts_discharge"};

/* Timestamp for checking timeouts in states */
uint32_t state_entered_timestamp = 0U;

/* List of state functions */
state_func_t *const VFSM_state_table[VFSM_NUM_STATES] = {
  VFSM_do_init,               // in state init
  VFSM_do_enable_inv_updates, // in state enable_inv_updates
  VFSM_do_check_inv_settings, // in state check_inv_settings
  VFSM_do_idle,               // in state idle
  VFSM_do_fatal_error,        // in state fatal_error
  VFSM_do_start_ts_precharge, // in state start_ts_precharge
  VFSM_do_wait_ts_precharge,  // in state wait_ts_precharge
  VFSM_do_start_ts_discharge, // in state start_ts_discharge
  VFSM_do_wait_driver,        // in state wait_driver
  VFSM_do_enable_inv_drive,   // in state enable_inv_drive
  VFSM_do_drive,              // in state drive
  VFSM_do_disable_inv_drive,  // in state disable_inv_drive
  VFSM_do_wait_ts_discharge,  // in state wait_ts_discharge
};


/* utility function to update the CAN status message */
void _VFSM_update_CarStatus(VFSM_state_t curr_state) {
  primary_car_status_car_status s;

  switch (curr_state) {
    case VFSM_STATE_INIT:
      s = primary_car_status_car_status_INIT;
      break;
    case VFSM_STATE_ENABLE_INV_UPDATES:
      s = primary_car_status_car_status_ENABLE_INV_UPDATES;
      break;
    case VFSM_STATE_CHECK_INV_SETTINGS:
      s = primary_car_status_car_status_CHECK_INV_SETTINGS;
      break;
    case VFSM_STATE_IDLE:
      s = primary_car_status_car_status_IDLE;
      break;
    case VFSM_STATE_START_TS_PRECHARGE:
      s = primary_car_status_car_status_START_TS_PRECHARGE;
      break;
    case VFSM_STATE_WAIT_TS_PRECHARGE:
      s = primary_car_status_car_status_WAIT_TS_PRECHARGE;
      break;
    case VFSM_STATE_WAIT_DRIVER:
      s = primary_car_status_car_status_WAIT_DRIVER;
      break;
    case VFSM_STATE_ENABLE_INV_DRIVE:
      s = primary_car_status_car_status_ENABLE_INV_DRIVE;
      break;
    case VFSM_STATE_DRIVE:
      s = primary_car_status_car_status_DRIVE;
      break;
    case VFSM_STATE_DISABLE_INV_DRIVE:
      s = primary_car_status_car_status_DISABLE_INV_DRIVE;
      break;
    case VFSM_STATE_START_TS_DISCHARGE:
      s = primary_car_status_car_status_START_TS_DISCHARGE;
      break;
    case VFSM_STATE_WAIT_TS_DISCHARGE:
      s = primary_car_status_car_status_WAIT_TS_DISCHARGE;
      break;
    case VFSM_STATE_FATAL_ERROR:
      s = primary_car_status_car_status_FATAL_ERROR;
      break;
    default:
      s = primary_car_status_car_status_IDLE;
  }

  CANMSG_CarStatus.data.car_status = s;
  CANMSG_CarStatus.info.is_new = true;
}

/*  ____  _        _       
 * / ___|| |_ __ _| |_ ___ 
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *                         
 *   __                  _   _                 
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___ 
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */                                             

// Function to be executed in state init
VFSM_state_t VFSM_do_init(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_STATE_IDLE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state init");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_INIT);
  
  HAL_Delay(100); // #YOLO
  next_state = VFSM_STATE_ENABLE_INV_UPDATES;
  
  switch (next_state) {
    case VFSM_STATE_ENABLE_INV_UPDATES:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from init to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state enable_inv_updates
VFSM_state_t VFSM_do_enable_inv_updates(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;

  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state enable_inv_updates");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_ENABLE_INV_UPDATES);
  
  /* Ensure the inverters' power outputs are disabled */
  // INV_power_off();
  
  /* Check if all updates are live */
  // TODO: scommentare queste righe
  // uint32_t tout_ms = primary_watchdog_interval_from_id(PRIMARY_INV_R_RESPONSE_FRAME_ID) * 1.5f;
  // bool status_on  = (HAL_GetTick() - CANMSG_InvL_Status.info.timestamp) < tout_ms;
  //      status_on &= (HAL_GetTick() - CANMSG_InvR_Status.info.timestamp) < tout_ms;
  // bool ioinfo_on  = (HAL_GetTick() - CANMSG_InvL_IOInfo.info.timestamp) < tout_ms;
  //      ioinfo_on &= (HAL_GetTick() - CANMSG_InvR_IOInfo.info.timestamp) < tout_ms;
  // bool errors_on  = (HAL_GetTick() - CANMSG_InvL_Errors.info.timestamp) < tout_ms;
  //      errors_on &= (HAL_GetTick() - CANMSG_InvR_Errors.info.timestamp) < tout_ms;
  // bool speed_on   = (HAL_GetTick() - CANMSG_InvL_Speed.info.timestamp)  < tout_ms;
  //      speed_on  &= (HAL_GetTick() - CANMSG_InvR_Speed.info.timestamp)  < tout_ms;
  // bool m_temp_on  = (HAL_GetTick() - CANMSG_InvL_MTemp.info.timestamp)  < tout_ms;
  //      m_temp_on &= (HAL_GetTick() - CANMSG_InvR_MTemp.info.timestamp)  < tout_ms;
  // bool i_temp_on  = (HAL_GetTick() - CANMSG_InvL_ITemp.info.timestamp)  < tout_ms;
  //      i_temp_on &= (HAL_GetTick() - CANMSG_InvR_ITemp.info.timestamp)  < tout_ms;

  /* When enabling regular updates, introduce minor delays to unsync them */
  // if (!status_on) {
  //   INV_enable_regid_updates(INV_REG_STATUS);
  //   HAL_Delay(51);
  // }
  // if (!ioinfo_on) {
  //   INV_enable_regid_updates(INV_REG_IOINFO);
  //   HAL_Delay(51);
  // }
  // if (!errors_on) {
  //   INV_enable_regid_updates(INV_REG_ERRORS);
  //   HAL_Delay(51);
  // }
  // if (!speed_on) {
  //   INV_enable_regid_updates(INV_REG_SPEED);
  //   HAL_Delay(51);
  // }
  // if (!m_temp_on) {
  //   INV_enable_regid_updates(INV_REG_MOT_TEMP);
  //   HAL_Delay(51);
  // }
  // if (!i_temp_on) {
  //   INV_enable_regid_updates(INV_REG_INV_TEMP);
  //   HAL_Delay(51);
  // }

  // LOG_write(LOGLEVEL_DEBUG,
  //   "INV/Updates: status=%d, io=%d, err=%d, speed=%d",
  //   status_on, ioinfo_on, errors_on, speed_on
  // );

  // if (status_on && ioinfo_on && errors_on && speed_on && m_temp_on && i_temp_on)
  //   next_state = VFSM_STATE_CHECK_INV_SETTINGS;
  // else
  //   next_state = VFSM_NO_CHANGE;
  
  #warning "[FSM] !!! Skipping inv. enable updates !!!"
  LOG_write(LOGLEVEL_WARN, "[FSM] !!! Skipping inv. enable updates !!!");
  next_state = VFSM_STATE_CHECK_INV_SETTINGS;

  switch (next_state) {
    case VFSM_STATE_ENABLE_INV_UPDATES:
    case VFSM_STATE_CHECK_INV_SETTINGS:
    case VFSM_NO_CHANGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from enable_inv_updates to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state check_inv_settings
VFSM_state_t VFSM_do_check_inv_settings(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_STATE_IDLE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state check_inv_settings");
  #endif

  _VFSM_update_CarStatus(VFSM_STATE_CHECK_INV_SETTINGS);
  
  LOG_write(LOGLEVEL_WARN, "[FSM] !!! Skipping inv. check settings !!!");
  #warning "TODO: Check inverters' settings"
  next_state = VFSM_STATE_IDLE;
  
  switch (next_state) {
    case VFSM_STATE_CHECK_INV_SETTINGS:
    case VFSM_STATE_IDLE:
    case VFSM_STATE_FATAL_ERROR:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from check_inv_settings to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state idle
VFSM_state_t VFSM_do_idle(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state idle");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_IDLE);

  /* Ensure the TS is OFF */
  TS_power_off();
  CANMSG_SetInvConnStatus.data.status = primary_ts_status_ts_status_OFF;
  CANMSG_SetInvConnStatus.info.is_new = true;
  // INV_R_set_torque_percent(0);
  // INV_L_set_torque_percent(0);
  
  /* Check for a TS-ON request */
  if (CANMSG_SetCarStatus.data.car_status_set == primary_set_car_status_car_status_set_READY && CANMSG_SetCarStatus.info.is_new) {
    next_state = VFSM_STATE_START_TS_PRECHARGE;
    CANMSG_SetCarStatus.info.is_new = false;
  }

  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_IDLE:
    case VFSM_STATE_FATAL_ERROR:
    case VFSM_STATE_START_TS_PRECHARGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from idle to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state fatal_error
VFSM_state_t VFSM_do_fatal_error(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state fatal_error");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_FATAL_ERROR);

  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_FATAL_ERROR:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from fatal_error to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_ts_precharge
VFSM_state_t VFSM_do_start_ts_precharge(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state start_ts_precharge");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_START_TS_PRECHARGE);

  /* If we have just entered, update the timestamp */
  if (state_entered_timestamp == 0U) {
    state_entered_timestamp = HAL_GetTick();
  }
  
  if (false) { // HAL_GetTick() - state_entered_timestamp > 15*1000) {
    /* We had a timeout, go back */
    state_entered_timestamp = 0U;
    next_state = VFSM_STATE_START_TS_DISCHARGE;
  } else {
    /* Check if precharge has started and go forward */
    TS_StatusTypeDef pork = TS_get_status();

    if (pork == TS_STATUS_PRECHARGE || pork == TS_STATUS_ON) {
      next_state = VFSM_STATE_WAIT_TS_PRECHARGE;
    } else if (pork == TS_STATUS_OFF) {
      TS_power_on();
      next_state = VFSM_NO_CHANGE;
    } else {
      next_state = VFSM_STATE_START_TS_DISCHARGE;
    }
  }

  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_START_TS_PRECHARGE:
    case VFSM_STATE_WAIT_TS_PRECHARGE:
    case VFSM_STATE_START_TS_DISCHARGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from start_ts_precharge to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state wait_ts_precharge
VFSM_state_t VFSM_do_wait_ts_precharge(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state wait_ts_precharge");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_WAIT_TS_PRECHARGE);

  /* If we have just entered, update the timestamp */
  if (state_entered_timestamp == 0U) {
    state_entered_timestamp = HAL_GetTick();
  }
  
  if (HAL_GetTick() - state_entered_timestamp > 30*1000) {
    /* We had a timeout, abort */
    state_entered_timestamp = 0U;
    next_state = VFSM_STATE_START_TS_DISCHARGE;
  } else {
    /* Check if precharge has finished and go forward */
    switch (TS_get_status()) {
      case TS_STATUS_PRECHARGE:
        next_state = VFSM_NO_CHANGE;
        break;
      case TS_STATUS_ON:
        next_state = VFSM_STATE_WAIT_DRIVER;
        break;
      default:
        next_state = VFSM_STATE_START_TS_DISCHARGE;
        break;
    }
  }
  
  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_WAIT_TS_PRECHARGE:
    case VFSM_STATE_WAIT_DRIVER:
    case VFSM_STATE_START_TS_DISCHARGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from wait_ts_precharge to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state wait_driver
VFSM_state_t VFSM_do_wait_driver(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state wait_driver");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_WAIT_DRIVER);

  /* Check for relevant events */
  if (true) { // TS_get_status() != TS_STATUS_ON) {
    /* Abort sequence */
    next_state = VFSM_STATE_START_TS_DISCHARGE;
  } else if (CANMSG_SetCarStatus.info.is_new) {
    primary_set_car_status_car_status_set s = CANMSG_SetCarStatus.data.car_status_set;

    if (s == primary_set_car_status_car_status_set_IDLE) {
      /* New set IDLE message */
      next_state = VFSM_STATE_START_TS_DISCHARGE;
    } else if (s == primary_set_car_status_car_status_set_DRIVE && PED_get_brake_percent() >= 5.0f) {
      /* New set DRIVE message */
      next_state = VFSM_STATE_ENABLE_INV_DRIVE;
    }

    CANMSG_SetCarStatus.info.is_new = false;
  }

  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_WAIT_DRIVER:
    case VFSM_STATE_ENABLE_INV_DRIVE:
    case VFSM_STATE_START_TS_DISCHARGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from wait_driver to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state enable_inv_drive
VFSM_state_t VFSM_do_enable_inv_drive(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state enable_inv_drive");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_ENABLE_INV_DRIVE);
  
  // bool RFE_on = INV_L_get_status()->RFE_switch && INV_R_get_status()->RFE_switch;
  // bool RUN_on = INV_L_get_status()->RUN_switch && INV_R_get_status()->RUN_switch;
  // bool DRV_on = INV_L_get_status()->drive_enabled && INV_R_get_status()->drive_enabled;
// 
  // if (!RFE_on || !RUN_on) {
  //   CANMSG_SetInvConnStatus.data.status = primary_Toggle_ON;
  //   CANMSG_SetInvConnStatus.info.is_new = true;
  // } else if (!DRV_on) {
  //   INV_power_on();
  // } else { /* RFE_on && RUN_on && DRV_on */
  //   BUZ_beep_ms_async(1500);
  //   next_state = VFSM_STATE_DRIVE;
  // }
  // 
  // if (TS_get_status() != TS_STATUS_ON)
  //   next_state = VFSM_STATE_DISABLE_INV_DRIVE;
  
  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_ENABLE_INV_DRIVE:
    case VFSM_STATE_DRIVE:
    case VFSM_STATE_DISABLE_INV_DRIVE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from enable_inv_drive to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}

// Function to be executed in state drive
VFSM_state_t VFSM_do_drive(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state drive");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_DRIVE);

  if (CANMSG_SetCarStatus.data.car_status_set == primary_set_car_status_car_status_set_IDLE && CANMSG_SetCarStatus.info.is_new) {
    CANMSG_SetCarStatus.info.is_new = false;
    next_state = VFSM_STATE_DISABLE_INV_DRIVE;
  } else {
    // DAS_do_drive_routine();
    
    // if (TS_get_status() != TS_STATUS_ON) {
    //   INV_L_set_torque_percent(0);
    //   INV_R_set_torque_percent(0);
    //   next_state = VFSM_STATE_DISABLE_INV_DRIVE;
    // }
  }

  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_DRIVE:
    case VFSM_STATE_DISABLE_INV_DRIVE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from drive to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}

// Function to be executed in state disable_inv_drive
VFSM_state_t VFSM_do_disable_inv_drive(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state disable_inv_drive");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_DISABLE_INV_DRIVE);
  
  // if (!INV_L_get_status()->drive_enabled && !INV_R_get_status()->drive_enabled)
  //   next_state = VFSM_STATE_START_TS_DISCHARGE;
  // else
  //   INV_power_off();
  
  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_DISABLE_INV_DRIVE:
    case VFSM_STATE_START_TS_DISCHARGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from disable_inv_drive to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}


// Function to be executed in state start_ts_discharge
VFSM_state_t VFSM_do_start_ts_discharge(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state start_ts_discharge");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_START_TS_DISCHARGE);

  TS_StatusTypeDef pork = TS_get_status();
  
  if (pork == TS_STATUS_ON || pork == TS_STATUS_PRECHARGE) {
    TS_power_off();
    next_state = VFSM_NO_CHANGE;
  } else {
    next_state = VFSM_STATE_WAIT_TS_DISCHARGE;
  }
  
  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_START_TS_DISCHARGE:
    case VFSM_STATE_WAIT_TS_DISCHARGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from start_ts_off to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}

// Function to be executed in state wait_ts_discharge
VFSM_state_t VFSM_do_wait_ts_discharge(VFSM_state_data_t *data) {
  VFSM_state_t next_state = VFSM_NO_CHANGE;
  
  #if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state wait_ts_discharge");
  #endif

  /* Update the car status message */
  _VFSM_update_CarStatus(VFSM_STATE_WAIT_TS_DISCHARGE);

  /* Ensure the SD is open */
  HAL_GPIO_WritePin(SD_CLOSE_GPIO_Port, SD_CLOSE_Pin, GPIO_PIN_RESET);

  /* Wait until the BMS-HV no longer reports more than 60 Volts */
  if (!CANMSG_HVFeedbacks.data.feedbacks_status_feedback_ts_over_60v_status) {
    next_state = VFSM_NO_CHANGE;
  } else {
    /* Go to idle and close back the SD circuit */
    next_state = VFSM_STATE_IDLE;
    HAL_GPIO_WritePin(SD_CLOSE_GPIO_Port, SD_CLOSE_Pin, GPIO_PIN_SET);
  }

  switch (next_state) {
    case VFSM_NO_CHANGE:
    case VFSM_STATE_IDLE:
    case VFSM_STATE_WAIT_TS_DISCHARGE:
      break;
    default:
      LOG_write(LOGLEVEL_WARN, "[FSM] Cannot pass from wait_ts_discharge to %s, remaining in this state", VFSM_state_names[next_state]);
      next_state = VFSM_NO_CHANGE;
  }
  
  return next_state;
}

/*  ____  _        _        
 * / ___|| |_ __ _| |_ ___  
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/ 
 * |____/ \__\__,_|\__\___| 
 *                          
 *                                              
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __ 
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |   
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|   
 *                              |___/           
 */

VFSM_state_t VFSM_run_state(VFSM_state_t cur_state, VFSM_state_data_t *data) {
  VFSM_state_t new_state = VFSM_state_table[cur_state](data);
  if (new_state == VFSM_NO_CHANGE) new_state = cur_state;
  return new_state == VFSM_NO_CHANGE ? cur_state : new_state;
}
