/******************************************************************************
Finite State Machine
Project: Docs/fsm.dot
Description: vehicle_fsm

Generated by gv_fsm ruby gem, see https://rubygems.org/gems/gv_fsm
gv_fsm version 0.3.4
Generation date: 2024-08-07 11:43:48 +0200
Generated from: Docs/fsm.dot
The finite state machine has:
  14 states
  0 transition functions
******************************************************************************/

#include "fsm.h"

// SEARCH FOR Your Code Here FOR CODE INSERTION POINTS!

/* Timestamp for checking timeouts in states */
uint32_t state_entered_timestamp = 0U;
uint8_t reset_inverters          = 0U;

// GLOBALS
// State human-readable names
const char *state_names[] = {
    "init",
    "enable_inv_updates",
    "check_inv_settings",
    "idle",
    "fatal_error",
    "start_ts_precharge",
    "wait_ts_precharge",
    "start_ts_discharge",
    "wait_driver",
    "enable_inv_drive",
    "drive",
    "disable_inv_drive",
    "re_enable_inv_drive",
    "wait_ts_discharge"};

// List of state functions
state_func_t *const state_table[NUM_STATES] = {
    do_init,                 // in state init
    do_enable_inv_updates,   // in state enable_inv_updates
    do_check_inv_settings,   // in state check_inv_settings
    do_idle,                 // in state idle
    do_fatal_error,          // in state fatal_error
    do_start_ts_precharge,   // in state start_ts_precharge
    do_wait_ts_precharge,    // in state wait_ts_precharge
    do_start_ts_discharge,   // in state start_ts_discharge
    do_wait_driver,          // in state wait_driver
    do_enable_inv_drive,     // in state enable_inv_drive
    do_drive,                // in state drive
    do_disable_inv_drive,    // in state disable_inv_drive
    do_re_enable_inv_drive,  // in state re_enable_inv_drive
    do_wait_ts_discharge,    // in state wait_ts_discharge
};
// No transition functions

void _VFSM_update_CarStatus(state_t state) {
    primary_ecu_status_status s = primary_ecu_status_status_fatal_error;

    switch (state) {
        case STATE_INIT: {
            s = primary_ecu_status_status_init;
            break;
        }
        case STATE_ENABLE_INV_UPDATES: {
            s = primary_ecu_status_status_enable_inv_updates;
            break;
        }
        case STATE_CHECK_INV_SETTINGS: {
            s = primary_ecu_status_status_check_inv_settings;
            break;
        }
        case STATE_IDLE: {
            s = primary_ecu_status_status_idle;
            break;
        }
        case STATE_FATAL_ERROR: {
            s = primary_ecu_status_status_fatal_error;
            break;
        }
        case STATE_START_TS_PRECHARGE: {
            s = primary_ecu_status_status_start_ts_precharge;
            break;
        }
        case STATE_WAIT_TS_PRECHARGE: {
            s = primary_ecu_status_status_wait_ts_precharge;
            break;
        }
        case STATE_START_TS_DISCHARGE: {
            s = primary_ecu_status_status_start_ts_discharge;
            break;
        }
        case STATE_WAIT_DRIVER: {
            s = primary_ecu_status_status_wait_driver;
            break;
        }
        case STATE_ENABLE_INV_DRIVE: {
            s = primary_ecu_status_status_enable_inv_drive;
            break;
        }
        case STATE_DRIVE: {
            s = primary_ecu_status_status_drive;
            break;
        }
        case STATE_DISABLE_INV_DRIVE: {
            s = primary_ecu_status_status_disable_inv_drive;
            break;
        }
        case STATE_RE_ENABLE_INV_DRIVE: {
            s = primary_ecu_status_status_re_enable_inverter_drive;
            break;
        }
        case STATE_WAIT_TS_DISCHARGE: {
            s = primary_ecu_status_status_wait_ts_discharge;
            break;
        }
        default:
            break;
    }

    ecumsg_ecu_status_state.data.status = s;
    ecumsg_ecu_status_state.info.is_new = true;
}

/*  ____  _        _
 * / ___|| |_ __ _| |_ ___
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *
 *   __                  _   _
 *  / _|_   _ _ __   ___| |_(_) ___  _ __  ___
 * | |_| | | | '_ \ / __| __| |/ _ \| '_ \/ __|
 * |  _| |_| | | | | (__| |_| | (_) | | | \__ \
 * |_|  \__,_|_| |_|\___|\__|_|\___/|_| |_|___/
 */

// Function to be executed in state init
// valid return states: STATE_ENABLE_INV_UPDATES
state_t do_init(state_data_t *data) {
    state_t next_state = STATE_ENABLE_INV_UPDATES;

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state init");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_INIT);

    HAL_Delay(100);  // #YOLO
    next_state = STATE_ENABLE_INV_UPDATES;
    /* Your Code Here */

    switch (next_state) {
        case STATE_ENABLE_INV_UPDATES:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state enable_inv_updates
// valid return states: NO_CHANGE, STATE_ENABLE_INV_UPDATES,
// STATE_CHECK_INV_SETTINGS
state_t do_enable_inv_updates(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state enable_inv_updates");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_ENABLE_INV_UPDATES);

    /* Ensure the inverters' power outputs are disabled */
    INV_disable_drive(INV_LEFT);
    INV_disable_drive(INV_RIGHT);

    /* Check if all updates are live */
    uint32_t tout_ms = 100.0f * 1.5f;
    bool i_cmd_ramp  = (HAL_GetTick() - CANMSG_InvL_I_CMD_RAMP.info.timestamp) < tout_ms;
    i_cmd_ramp &= (HAL_GetTick() - CANMSG_InvR_I_CMD_RAMP.info.timestamp) < tout_ms;
    bool i_cmd = (HAL_GetTick() - CANMSG_InvL_I_CMD.info.timestamp) < tout_ms;
    i_cmd &= (HAL_GetTick() - CANMSG_InvR_I_CMD.info.timestamp) < tout_ms;
    bool iq_actual = (HAL_GetTick() - CANMSG_InvL_IQ_ACTUAL.info.timestamp) < tout_ms;
    iq_actual &= (HAL_GetTick() - CANMSG_InvR_IQ_ACTUAL.info.timestamp) < tout_ms;
    bool id_actual = (HAL_GetTick() - CANMSG_InvL_ID_ACTUAL.info.timestamp) < tout_ms;
    id_actual &= (HAL_GetTick() - CANMSG_InvR_ID_ACTUAL.info.timestamp) < tout_ms;
    bool n_actual_filt = (HAL_GetTick() - CANMSG_InvL_N_ACTUAL_FILT.info.timestamp) < tout_ms;
    n_actual_filt &= (HAL_GetTick() - CANMSG_InvR_N_ACTUAL_FILT.info.timestamp) < tout_ms;
    bool n_cmd_ramp = (HAL_GetTick() - CANMSG_InvL_N_CMD_RAMP.info.timestamp) < tout_ms;
    n_cmd_ramp &= (HAL_GetTick() - CANMSG_InvR_N_CMD_RAMP.info.timestamp) < tout_ms;
    bool vdc_bus = (HAL_GetTick() - CANMSG_InvL_VDC_BUS.info.timestamp) < tout_ms;
    vdc_bus &= (HAL_GetTick() - CANMSG_InvR_VDC_BUS.info.timestamp) < tout_ms;

    // /* When enabling regular updates, introduce minor delays to unsync them */
    if (!i_cmd_ramp) {
        INV_enable_regid_updates(INVERTERS_INV_L_SEND_READ_ID_22H_I_CMD_RAMP_CHOICE, 10);
        HAL_Delay(51);
    }
    if (!i_cmd) {
        INV_enable_regid_updates(INVERTERS_INV_L_SEND_READ_ID_26H_I_CMD_CHOICE, 10);
        HAL_Delay(51);
    }
    if (!iq_actual) {
        INV_enable_regid_updates(INVERTERS_INV_L_SEND_READ_ID_27H_IQ_ACTUAL_CHOICE, 10);
        HAL_Delay(51);
    }
    if (!id_actual) {
        INV_enable_regid_updates(INVERTERS_INV_L_RCV_RCV_MUX_ID_28_ID_ACTUAL_CHOICE, 10);
        HAL_Delay(51);
    }
    if (!n_actual_filt) {
        INV_enable_regid_updates(INVERTERS_INV_L_SEND_READ_ID_A8H_N_ACTUAL_FILT_CHOICE, 10);
        HAL_Delay(51);
    }
    if (!n_cmd_ramp) {
        INV_enable_regid_updates(INVERTERS_INV_L_SEND_READ_ID_32H_N_CMD_RAMP_CHOICE, 10);
        HAL_Delay(51);
    }
    if (!vdc_bus) {
        INV_enable_regid_updates(INVERTERS_INV_L_SEND_READ_ID_EBH_VDC_BUS_CHOICE, 10);
        HAL_Delay(51);
    }

    // LOG_write(LOGLEVEL_DEBUG,
    //   "INV/Updates: status=%d, io=%d, err=%d, speed=%d",
    //   status_on, ioinfo_on, errors_on, speed_on
    // );

    if (i_cmd_ramp && i_cmd && iq_actual && id_actual && n_actual_filt && n_cmd_ramp && vdc_bus)
        next_state = STATE_CHECK_INV_SETTINGS;
    else
        next_state = NO_CHANGE;

    next_state = STATE_CHECK_INV_SETTINGS;

    switch (next_state) {
        case NO_CHANGE:
        case STATE_ENABLE_INV_UPDATES:
        case STATE_CHECK_INV_SETTINGS:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state check_inv_settings
// valid return states: NO_CHANGE, STATE_CHECK_INV_SETTINGS, STATE_IDLE,
// STATE_FATAL_ERROR
state_t do_check_inv_settings(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state check_inv_settings");
#endif

    _VFSM_update_CarStatus(STATE_CHECK_INV_SETTINGS);

    // LOG_write(LOGLEVEL_WARN, "[FSM] !!! Skipping inv. check settings !!!");
    if (INV_check_settings()) {
        LOG_write(LOGLEVEL_WARN, "[FSM] !!! Inverters' settings are correct !!!");
    } else {
        LOG_write(LOGLEVEL_WARN, "[FSM] !!! Inverters' settings are NOT correct !!!");
    }
#warning "TODO: Check inverters' settings"
    next_state = STATE_IDLE;

    switch (next_state) {
        case NO_CHANGE:
        case STATE_CHECK_INV_SETTINGS:
        case STATE_IDLE:
        case STATE_FATAL_ERROR:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state idle
// valid return states: NO_CHANGE, STATE_IDLE, STATE_FATAL_ERROR,
// STATE_START_TS_PRECHARGE
state_t do_idle(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state idle");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_IDLE);

    /* Ensure the TS is OFF */
    TS_power_off();
    ecumsg_lv_set_inverter_connection_status_state.data.status = primary_lv_set_inverter_connection_status_status_off;
    ecumsg_lv_set_inverter_connection_status_state.info.is_new = true;

    if (reset_inverters == 0U) {
        /* Ensure the inverters' power outputs are disabled */
        INV_disable_drive(INV_LEFT);
        INV_disable_drive(INV_RIGHT);
        reset_inverters = 1U;
    }

    /* Check for a TS-ON request */
    if (ecumsg_ecu_set_status_state.data.status == primary_ecu_set_status_status_ready && ecumsg_ecu_set_status_state.info.is_new) {
        next_state                              = STATE_START_TS_PRECHARGE;
        ecumsg_ecu_set_status_state.info.is_new = false;

        /* Check when SD is open (and therefore I have to go in discharge) */
        if (!is_SD_closed())
            next_state = STATE_IDLE;
        else if (ecumsg_hv_feedback_status_state.info.is_new && !ecumsg_hv_feedback_status_state.data.sd_end)
            next_state = STATE_IDLE;
    }

    DAS_do_drive_routine(0.0f);

#if WTCHDG_DEBUG
    if (!WDG_is_car_in_safe_state()) {
        next_state = VFSM_STATE_IDLE;
    }
#endif

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state idle");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_IDLE);

    /* Ensure the TS is OFF */
    TS_power_off();
    ecumsg_lv_set_inverter_connection_status_state.data.status = primary_lv_set_inverter_connection_status_status_off;
    ecumsg_lv_set_inverter_connection_status_state.info.is_new = true;

    if (reset_inverters == 0U) {
        /* Ensure the inverters' power outputs are disabled */
        INV_disable_drive(INV_LEFT);
        INV_disable_drive(INV_RIGHT);
        reset_inverters = 1U;
    }

    /* Check for a TS-ON request */
    if (ecumsg_ecu_set_status_state.data.status == primary_ecu_set_status_status_ready && ecumsg_ecu_set_status_state.info.is_new) {
        next_state                              = STATE_START_TS_PRECHARGE;
        ecumsg_ecu_set_status_state.info.is_new = false;

        /* Check when SD is open (and therefore I have to go in discharge) */
        if (!is_SD_closed())
            next_state = STATE_IDLE;
        else if (ecumsg_hv_feedback_status_state.info.is_new && !ecumsg_hv_feedback_status_state.data.sd_end)
            next_state = STATE_IDLE;
    }

#if WTCHDG_DEBUG
    if (!WDG_is_car_in_safe_state()) {
        next_state = VFSM_STATE_IDLE;
    }
#endif

    switch (next_state) {
        case NO_CHANGE:
        case STATE_IDLE:
        case STATE_FATAL_ERROR:
        case STATE_START_TS_PRECHARGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state fatal_error
// valid return states: NO_CHANGE, STATE_FATAL_ERROR
state_t do_fatal_error(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state fatal_error");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_FATAL_ERROR);

    switch (next_state) {
        case NO_CHANGE:
        case STATE_FATAL_ERROR:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state start_ts_precharge
// valid return states: NO_CHANGE, STATE_START_TS_PRECHARGE,
// STATE_WAIT_TS_PRECHARGE, STATE_START_TS_DISCHARGE
state_t do_start_ts_precharge(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state start_ts_precharge");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_START_TS_PRECHARGE);

    /* If we have just entered, update the timestamp */
    if (state_entered_timestamp == 0U) {
        state_entered_timestamp = HAL_GetTick();
    }

    if (HAL_GetTick() - state_entered_timestamp > 25 * 1000) {
        /* We had a timeout, go back */
        state_entered_timestamp = 0U;
        next_state              = STATE_START_TS_DISCHARGE;
    } else {
        /* Check if precharge has started and go forward */
        TS_StatusTypeDef pork = TS_get_status();

        if (pork == TS_STATUS_PRECHARGE || pork == TS_STATUS_ON) {
            next_state = STATE_WAIT_TS_PRECHARGE;
        } else if (pork == TS_STATUS_OFF) {
            TS_power_on();
            next_state = NO_CHANGE;
        } else if (pork == TS_STATUS_FATAL) {
            next_state = STATE_START_TS_DISCHARGE;
        }
    }

    /* Check when SD is open (and therefore I have to go in discharge) */
    if (!is_SD_closed())
        next_state = STATE_START_TS_DISCHARGE;
    else if (!ecumsg_hv_feedback_status_state.data.sd_end)
        next_state = STATE_START_TS_DISCHARGE;

#if WTCHDG_DEBUG
    if (!WDG_is_car_in_safe_state()) {
        next_state = VFSM_STATE_START_TS_DISCHARGE;
    }
#endif

    switch (next_state) {
        case NO_CHANGE:
        case STATE_START_TS_PRECHARGE:
        case STATE_WAIT_TS_PRECHARGE:
        case STATE_START_TS_DISCHARGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state wait_ts_precharge
// valid return states: NO_CHANGE, STATE_WAIT_TS_PRECHARGE, STATE_WAIT_DRIVER,
// STATE_START_TS_DISCHARGE
state_t do_wait_ts_precharge(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state wait_ts_precharge");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_WAIT_TS_PRECHARGE);

    /* If we have just entered, update the timestamp */
    if (state_entered_timestamp == 0U) {
        state_entered_timestamp = HAL_GetTick();
    }

    if (HAL_GetTick() - state_entered_timestamp > 30 * 1000) {
        /* We had a timeout, abort */
        // state_entered_timestamp = 0U;
        // next_state              = STATE_START_TS_DISCHARGE;
    } else {
        /* Check if precharge has finished and go forward */
        switch (TS_get_status()) {
            case TS_STATUS_PRECHARGE:
                next_state = NO_CHANGE;
                break;
            case TS_STATUS_ON:
                next_state = STATE_WAIT_DRIVER;
                break;
            default:
                next_state = STATE_START_TS_DISCHARGE;
                break;
        }
    }

#if WTCHDG_DEBUG
    if (!WDG_is_car_in_safe_state()) {
        next_state = VFSM_STATE_START_TS_DISCHARGE;
    }
#endif

    switch (next_state) {
        case NO_CHANGE:
        case STATE_WAIT_TS_PRECHARGE:
        case STATE_WAIT_DRIVER:
        case STATE_START_TS_DISCHARGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state start_ts_discharge
// valid return states: NO_CHANGE, STATE_START_TS_DISCHARGE,
// STATE_WAIT_TS_DISCHARGE
state_t do_start_ts_discharge(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state start_ts_discharge");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_START_TS_DISCHARGE);

    TS_StatusTypeDef pork = TS_get_status();

    if (pork == TS_STATUS_ON || pork == TS_STATUS_PRECHARGE) {
        TS_power_off();
        next_state = NO_CHANGE;
    } else {
        next_state = STATE_WAIT_TS_DISCHARGE;
    }

    switch (next_state) {
        case NO_CHANGE:
        case STATE_START_TS_DISCHARGE:
        case STATE_WAIT_TS_DISCHARGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state wait_driver
// valid return states: NO_CHANGE, STATE_WAIT_DRIVER, STATE_ENABLE_INV_DRIVE,
// STATE_START_TS_DISCHARGE
state_t do_wait_driver(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state wait_driver");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_WAIT_DRIVER);

    /* Check for relevant events */
    if (TS_get_status() != TS_STATUS_ON) {
        /* Abort sequence */
        next_state = STATE_START_TS_DISCHARGE;
    } else if (ecumsg_ecu_set_status_state.info.is_new) {
        primary_ecu_set_status_status s = ecumsg_ecu_set_status_state.data.status;

        if (s == primary_ecu_set_status_status_idle) {
            /* New set IDLE message */
            next_state = STATE_START_TS_DISCHARGE;
        } else if (s == primary_ecu_set_status_status_drive) {
            if (PED_get_brake_bar() >= BRK_THRESHOLD_HIGH) {
                /* New set DRIVE message */
                next_state = STATE_ENABLE_INV_DRIVE;
            } else {
                /* Send message to alert the driver to press the brake pedal */
                ecumsg_ecu_errors_state.data.error_no_brake_to_rtd = 1;
            }
        }

        ecumsg_ecu_set_status_state.info.is_new = false;
    }

#if WTCHDG_DEBUG
    if (!!WDG_is_car_in_safe_state()) {
        next_state = VFSM_STATE_START_TS_DISCHARGE;
    }
#endif

    switch (next_state) {
        case NO_CHANGE:
        case STATE_WAIT_DRIVER:
        case STATE_ENABLE_INV_DRIVE:
        case STATE_START_TS_DISCHARGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state enable_inv_drive
// valid return states: NO_CHANGE, STATE_ENABLE_INV_DRIVE, STATE_DRIVE,
// STATE_DISABLE_INV_DRIVE
state_t do_enable_inv_drive(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state enable_inv_drive");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_ENABLE_INV_DRIVE);

    // bms lv directly reads the ecu state so not needed
    // bool RFE_on = INV_get_RFE_state(INV_LEFT) && INV_get_RFE_state(INV_RIGHT);
    // bool RUN_on = INV_get_FRG_state(INV_LEFT) && INV_get_FRG_state(INV_RIGHT);
    bool DRV_on = INV_is_drive_enabled(INV_LEFT) && INV_is_drive_enabled(INV_RIGHT);

    if (ecumsg_ecu_set_status_state.data.status == primary_ecu_set_status_status_idle && ecumsg_ecu_set_status_state.info.is_new) {
        ecumsg_ecu_set_status_state.info.is_new = false;
        next_state                              = STATE_DISABLE_INV_DRIVE;
    } /* else if (!RFE_on || !RUN_on) {
        ecumsg_lv_set_inverter_connection_status_state.data.status = primary_lv_set_inverter_connection_status_status_on;
        ecumsg_lv_set_inverter_connection_status_state.info.is_new = true;
    } */
    else if (!DRV_on) {
        if (!INV_is_drive_enabled(INV_LEFT))
            INV_enable_drive(INV_LEFT);
        if (!INV_is_drive_enabled(INV_RIGHT))
            INV_enable_drive(INV_RIGHT);
    } else { /* RFE_on && RUN_on && DRV_on */
        BUZ_beep_ms_async(2000);
        next_state = STATE_DRIVE;
    }

    if (TS_get_status() != TS_STATUS_ON)
        next_state = STATE_DISABLE_INV_DRIVE;

#if WTCHDG_DEBUG
    if (!WDG_is_car_in_safe_state()) {
        next_state = VFSM_STATE_DISABLE_INV_DRIVE;
    }
#endif

    switch (next_state) {
        case NO_CHANGE:
        case STATE_ENABLE_INV_DRIVE:
        case STATE_DRIVE:
        case STATE_DISABLE_INV_DRIVE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state drive
// valid return states: NO_CHANGE, STATE_RE_ENABLE_INV_DRIVE, STATE_DRIVE,
// STATE_DISABLE_INV_DRIVE
state_t do_drive(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state drive");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_DRIVE);

    static uint32_t last_drive_send = 0;

    bool DRV_on = INV_is_drive_enabled(INV_LEFT) && INV_is_drive_enabled(INV_RIGHT);

    if (!DRV_on) {
        next_state = STATE_RE_ENABLE_INV_DRIVE;
        return next_state;
    }

    if (ecumsg_ecu_set_status_state.data.status == primary_ecu_set_status_status_idle && ecumsg_ecu_set_status_state.info.is_new) {
        ecumsg_ecu_set_status_state.info.is_new = false;
        next_state                              = STATE_DISABLE_INV_DRIVE;
    } else {
        if (HAL_GetTick() - last_drive_send >= 10) {
            last_drive_send = HAL_GetTick();
            if (DAS_do_drive_routine(PED_get_brake_bar())) {
                /* BSPD limits were applied */
                ecumsg_ecu_errors_state.data.error_bspd_limits = 1;
            } else {
                ecumsg_ecu_errors_state.data.error_bspd_limits = 0;
            }
        }

        if (TS_get_status() != TS_STATUS_ON) {
            INV_set_torque_Nm(INV_LEFT, 0);
            INV_set_torque_Nm(INV_RIGHT, 0);
            next_state = STATE_DISABLE_INV_DRIVE;
            LOG_write(LOGLEVEL_INFO, "TS_status: %d", TS_get_status());
        }
    }

#if WTCHDG_DEBUG
    if (!WDG_is_car_in_safe_state()) {
        next_state = STATE_DISABLE_INV_DRIVE;
    }
#endif

    switch (next_state) {
        case NO_CHANGE:
        case STATE_RE_ENABLE_INV_DRIVE:
        case STATE_DRIVE:
        case STATE_DISABLE_INV_DRIVE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state disable_inv_drive
// valid return states: NO_CHANGE, STATE_DISABLE_INV_DRIVE,
// STATE_START_TS_DISCHARGE
state_t do_disable_inv_drive(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state disable_inv_drive");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_DISABLE_INV_DRIVE);

    if (!INV_is_drive_enabled(INV_LEFT) && !INV_is_drive_enabled(INV_LEFT)) {
        next_state = STATE_START_TS_DISCHARGE;
    } else {
        INV_disable_drive(INV_LEFT);
        INV_disable_drive(INV_RIGHT);
    }

    switch (next_state) {
        case NO_CHANGE:
        case STATE_DISABLE_INV_DRIVE:
        case STATE_START_TS_DISCHARGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state re_enable_inv_drive
// valid return states: STATE_DRIVE
state_t do_re_enable_inv_drive(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state enable_inv_drive");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_RE_ENABLE_INV_DRIVE);

    // bool RFE_on = INV_get_RFE_state(INV_LEFT) && INV_get_RFE_state(INV_RIGHT);
    // bool RUN_on = INV_get_FRG_state(INV_LEFT) && INV_get_FRG_state(INV_RIGHT);
    bool DRV_on = INV_is_drive_enabled(INV_LEFT) && INV_is_drive_enabled(INV_RIGHT);

    if (ecumsg_ecu_set_status_state.data.status == primary_ecu_set_status_status_idle && ecumsg_ecu_set_status_state.info.is_new) {
        ecumsg_ecu_set_status_state.info.is_new = false;
        next_state                              = STATE_DISABLE_INV_DRIVE;
    } /* else if (!RFE_on || !RUN_on) {
        ecumsg_lv_set_inverter_connection_status_state.data.status = primary_lv_set_inverter_connection_status_status_on;
        ecumsg_lv_set_inverter_connection_status_state.info.is_new = true;
    } */
    else if (!DRV_on) {
        if (!INV_is_drive_enabled(INV_LEFT))
            INV_enable_drive(INV_LEFT);
        if (!INV_is_drive_enabled(INV_RIGHT))
            INV_enable_drive(INV_RIGHT);
    } else { /* RFE_on && RUN_on && DRV_on */
        // BUZ_beep_ms_async(2000); // not needed if re-enabling the inverters
        next_state = STATE_DRIVE;
    }

    if (TS_get_status() != TS_STATUS_ON)
        next_state = STATE_DISABLE_INV_DRIVE;

#if WTCHDG_DEBUG
    if (!WDG_is_car_in_safe_state()) {
        next_state = VFSM_STATE_DISABLE_INV_DRIVE;
    }
#endif

    switch (next_state) {
        case STATE_DRIVE:
        case STATE_DISABLE_INV_DRIVE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

// Function to be executed in state wait_ts_discharge
// valid return states: NO_CHANGE, STATE_IDLE, STATE_WAIT_TS_DISCHARGE
state_t do_wait_ts_discharge(state_data_t *data) {
    state_t next_state = NO_CHANGE;

    /* Your Code Here */

#if FSM_DEBUG
    LOG_write(LOGLEVEL_DEBUG, "[FSM] In state wait_ts_discharge");
#endif

    /* Update the car status message */
    _VFSM_update_CarStatus(STATE_WAIT_TS_DISCHARGE);

    /* Ensure the SD is open */
    HAL_GPIO_WritePin(SD_CLOSE_GPIO_Port, SD_CLOSE_Pin, GPIO_PIN_RESET);

    /* Wait until the BMS-HV no longer reports more than 60 Volts */
    if (ecumsg_hv_feedback_status_state.data.ts_less_than_60v) {
        next_state = NO_CHANGE;
    } else {
        /* Go to idle and close back the SD circuit */
        next_state      = STATE_IDLE;
        reset_inverters = 0U;
        HAL_GPIO_WritePin(SD_CLOSE_GPIO_Port, SD_CLOSE_Pin, GPIO_PIN_SET);
    }

    switch (next_state) {
        case NO_CHANGE:
        case STATE_IDLE:
        case STATE_WAIT_TS_DISCHARGE:
            break;
        default:
            next_state = NO_CHANGE;
    }

    return next_state;
}

/*  ____  _        _
 * / ___|| |_ __ _| |_ ___
 * \___ \| __/ _` | __/ _ \
 *  ___) | || (_| | ||  __/
 * |____/ \__\__,_|\__\___|
 *
 *
 *  _ __ ___   __ _ _ __   __ _  __ _  ___ _ __
 * | '_ ` _ \ / _` | '_ \ / _` |/ _` |/ _ \ '__|
 * | | | | | | (_| | | | | (_| | (_| |  __/ |
 * |_| |_| |_|\__,_|_| |_|\__,_|\__, |\___|_|
 *                              |___/
 */

state_t run_state(state_t cur_state, state_data_t *data) {
    state_t new_state = state_table[cur_state](data);
    if (new_state == NO_CHANGE)
        new_state = cur_state;
    return new_state;
};

#ifdef TEST_MAIN
#include <unistd.h>
int main() {
    state_t cur_state = STATE_INIT;
    do {
        cur_state = run_state(cur_state, NULL);
        sleep(1);
    } while (1);
    return 0;
}
#endif
